// This is the rclone build script. It can build rclone binaries for any target
// architecture on any target architecture.

import groovy.json.JsonSlurper
import java.nio.file.Paths

ext {
    NDK_VERSION = project.properties['de.felixnuesse.extract.ndkVersion']
    NDK_TOOLCHAIN_VERSION = project.properties['de.felixnuesse.extract.ndkToolchainVersion']
    RCLONE_VERSION = project.properties['de.felixnuesse.extract.rCloneVersion']
    GO_REQ_VERSION = project.properties['de.felixnuesse.extract.goVersion']
    
    // 1. Use the OFFICIAL module name so internal imports inside the code work.
    RCLONE_MODULE = 'github.com/rclone/rclone'     
    
    // 2. Define the Filen fork URL for the replacement.
    RCLONE_FORK_MODULE = 'github.com/FilenCloudDienste/filen-rclone'
    
    // 3. Set suffix to empty because your gradle.properties version already has "-filen"
    RCLONE_CUSTOM_VERSION_SUFFIX = '' 

    PROJECT_DIR = projectDir.absolutePath
    CACHE_PATH = Paths.get(PROJECT_DIR, 'cache').toString()
    GOPATH = Paths.get(CACHE_PATH, 'gopath').toString()
    OUTPUT_BASE_PATH = Paths.get(PROJECT_DIR, '..', 'app', 'lib').toAbsolutePath().toString()
}

def findSdkDir() {
    def androidHome = System.getenv('ANDROID_HOME')
    if (androidHome != null) {
        return androidHome
    }

    def localPropertiesFile = project.rootProject.file('local.properties')
    if (localPropertiesFile.exists()) {
        Properties properties = new Properties()
        properties.load(localPropertiesFile.newDataInputStream())
        def sdkDir = properties.get('sdk.dir')
        if (sdkDir != null) {
            return sdkDir
        }
    }

    throw new GradleException(
        "Couldn't locate your android SDK. Make sure you set sdk.dir property"
        + " in your local.properties at the root of the project or set"
        + " ANDROID_HOME environment variable."
    )
}

def findNdkDir() {
    def sdkDir = findSdkDir()
    def ndkPath = Paths.get(sdkDir, 'ndk', NDK_VERSION).toAbsolutePath()
    if (!ndkPath.toFile().exists()) {
        def sdkManagerPath = Paths.get(
            sdkDir,
            'cmdline-tools',
            'latest',
            'bin',
            'sdkmanager'
        ).toString()
        if (System.properties['os.name'].startsWith('Windows')) {
            sdkManagerPath += '.bat'
        }
        try {
            exec {
                commandLine sdkManagerPath, "--install", "ndk;${NDK_VERSION}"
            }
        } catch (exc) {
            logger.error(exc.toString())
            throw new GradleException(
                "Couldn't find a ndk bundle in ${ndkPath.toString()}."
            )
        }
    }
    return ndkPath.toString()
}

def getCrossCompiler(abi) {
    def osName = System.properties['os.name']
    def osArch = System.properties['os.arch']
    def os = null
    if (osName.startsWith('Windows') && osArch == 'amd64') {
        os = 'windows-x86_64'
    } else if (osName.startsWith('Linux') && osArch == 'amd64') {
        os = 'linux-x86_64'
    } else if (osName.startsWith('Mac') && ['aarch64', 'amd64'].contains(osArch)) {
        os = 'darwin-x86_64'
    }
    if (os == null) {
        throw new GradleException('Unsupported host OS or architecture.')
    }

    def abiToCompiler = [
        'armeabi-v7a': "armv7a-linux-androideabi${NDK_TOOLCHAIN_VERSION}-clang",
        'arm64-v8a': "aarch64-linux-android${NDK_TOOLCHAIN_VERSION}-clang",
        'x86': "i686-linux-android${NDK_TOOLCHAIN_VERSION}-clang",
        'x86_64': "x86_64-linux-android${NDK_TOOLCHAIN_VERSION}-clang",
    ]

    return Paths.get(
        findNdkDir(),
        'toolchains',
        'llvm',
        'prebuilt',
        os,
        'bin',
        abiToCompiler[abi],
    )
}

def getOutputPath(abi) {
    return Paths.get(OUTPUT_BASE_PATH, abi, 'librclone.so').toString()
}

def buildRclone(abi) {
    def abiToEnv = [
        'armeabi-v7a': ['GOARCH': 'arm', 'GOARM': '7'],
        'arm64-v8a': ['GOARCH': 'arm64'],
        'x86': ['GOARCH': '386'],
        'x86_64': ['GOARCH': 'amd64'],
    ]

    return {
        doLast {
            exec {
                // FIX: workingDir moved inside exec
                workingDir CACHE_PATH
                environment 'GOPATH', GOPATH
                
                def crossCompiler = getCrossCompiler(abi)
                environment 'CC', crossCompiler
                environment 'CC_FOR_TARGET', crossCompiler
                environment 'GOOS', 'android'
                environment 'CGO_ENABLED', '1'
                environment 'CGO_LDFLAGS', '-fuse-ld=lld -Wl,--hash-style=both -s'
                abiToEnv[abi].each {entry -> environment entry.key, entry.value}
                
                // We use RCLONE_MODULE (rclone/rclone) here to match the source code
                // We add 'v' to fs.Version to match standard rclone output style
                def ldflags = "-buildid= -X ${RCLONE_MODULE}/fs.Version=v${RCLONE_VERSION}${RCLONE_CUSTOM_VERSION_SUFFIX}"
                
                commandLine (
                    'go',
                    'build',
                    '-tags',
                    'android noselfupdate',
                    '-trimpath',
                    '-ldflags',
                    ldflags,
                    '-o',
                    getOutputPath(abi),
                    RCLONE_MODULE
                )
            }
        }
    }
}

task createRcloneModule(type: Exec) {
    onlyIf { !Paths.get(CACHE_PATH, 'go.mod').toFile().exists() }
    Paths.get(CACHE_PATH).toFile().mkdirs()
    workingDir CACHE_PATH
    environment 'GOPATH', GOPATH
    commandLine 'go', 'mod', 'init', 'rclone'
}

task checkoutRclone {
    dependsOn createRcloneModule
    
    doLast {
        // 1. Check Go Version
        def goVersionOutput = new ByteArrayOutputStream()
        exec {
            // FIX: workingDir moved inside exec
            workingDir CACHE_PATH
            environment 'GOPATH', GOPATH
            commandLine 'go', 'version'
            standardOutput = goVersionOutput
        }

        if (goVersionOutput.toString().contains(GO_REQ_VERSION)) {
            println "You are running the required go version."
        } else {
            logger.error("The required go version is: ${GO_REQ_VERSION}")
            logger.error("You are running: ${goVersionOutput}")
        }
        
        println "Preparing to build rclone fork: ${RCLONE_FORK_MODULE} @ v${RCLONE_VERSION}"

        // 2. Add REPLACE directive
        // FIX: Added 'v' before ${RCLONE_VERSION} because gradle.properties doesn't have it
        exec {
            workingDir CACHE_PATH
            environment 'GOPATH', GOPATH
            commandLine 'go', 'mod', 'edit', '-replace', "github.com/rclone/rclone=${RCLONE_FORK_MODULE}@v${RCLONE_VERSION}"
        }

        // 3. Get the module
        // We ask for strict rclone, but get the fork due to replacement
        exec {
            workingDir CACHE_PATH
            environment 'GOPATH', GOPATH
            commandLine 'go', 'get', '-v', "${RCLONE_MODULE}" 
        }

        // 4. Tidy dependencies
        exec {
            workingDir CACHE_PATH
            environment 'GOPATH', GOPATH
            commandLine 'go', 'mod', 'tidy'
        }
    }
}

task buildArm(dependsOn: checkoutRclone) {
    configure buildRclone('armeabi-v7a')
}

task buildArm64(dependsOn: checkoutRclone) {
    configure buildRclone('arm64-v8a')
}

task buildx86(dependsOn: checkoutRclone) {
    configure buildRclone('x86')
}

task buildx64(dependsOn: checkoutRclone) {
    configure buildRclone('x86_64')
}

task buildAll {
    dependsOn buildArm, buildArm64, buildx86, buildx64
}

task clean {
    doLast {
        exec {
            workingDir CACHE_PATH
            environment 'GOPATH', GOPATH
            commandLine 'go', 'clean', '-cache', '-testcache', '-modcache', '-fuzzcache'
        }
        delete CACHE_PATH
        delete fileTree(OUTPUT_BASE_PATH).matching {
            include '**/librclone.so'
        }
    }
}

defaultTasks 'buildAll'